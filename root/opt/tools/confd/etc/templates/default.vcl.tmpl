vcl 4.0;
import directors;

{{/* Set vcl_recv to pipe mode for known bots. Only added if the environment variable NOBOTS=true is found */}}
{{- define "NOBOTS" -}}
	# Bots require special versions of the page, pipe them through and don't
	# cache what they see
	if (
			req.http.User-Agent ~ "(?i)Googlebot"
			|| req.http.User-Agent ~ "(?i)AdsBot-Google"
			|| req.http.User-Agent ~ "(?i)Mediapartners-Google"
			|| req.http.User-Agent ~ "(?i)Slurp"
			|| req.http.User-Agent ~ "(?i)search.msn.com"
			|| req.http.User-Agent ~ "(?i)nutch"
			|| req.http.User-Agent ~ "(?i)simpy"
			|| req.http.User-Agent ~ "(?i)ASPSeek"
			|| req.http.User-Agent ~ "(?i)crawler"
			|| req.http.User-Agent ~ "(?i)msnbot"
			|| req.http.User-Agent ~ "(?i)Libwww-perl"
			|| req.http.User-Agent ~ "(?i)FAST"
			|| req.http.User-Agent ~ "(?i)Baidu"
			|| req.http.User-Agent ~ "(?i)Clapp\/Mobile Kaufland"
		) {
		return (pipe);
	}
{{- end -}}

{{- range $i, $stackName := ls "/self/service/links" -}}

        {{- $backendPrefix := getenv "BACKEND_PREFIX" -}}

        {{- range $i2, $serviceName := ls (printf "/stacks/%s/services" $stackName) -}}
                {{- $serviceSplit := getenv "BACKEND_DIVIDER" -}}

                {{- $servicePrefix := index (split $serviceName $serviceSplit) 0 -}}

                {{- if eq $backendPrefix $servicePrefix -}}

                        {{- $path := (printf "/stacks/%s/services/%s/containers" $stackName $serviceName) -}}

                        {{- range $i3, $containerId := ls $path }}

backend {{ printf "backend_%d_%d_%d" $i $i2 $i3 }} {
        .host = "{{ getv (printf "%s/%s/primary_ip" $path $containerId) }}";
        .port = "80";
}
                        {{- end -}}
                {{ end -}}
        {{- end -}}

{{- end }}

sub vcl_init {

        new vdir = directors.round_robin();
{{- range $stackIdx, $stackName := ls "/self/service/links" -}}

        {{- $backendPrefix := getenv "BACKEND_PREFIX" -}}

        {{- range $serviceIdx, $serviceName := ls (printf "/stacks/%s/services" $stackName) -}}
                {{- $serviceSplit := getenv "BACKEND_DIVIDER" -}}

                {{- $servicePrefix := index (split $serviceName $serviceSplit) 0 -}}

                {{- if eq $backendPrefix $servicePrefix -}}

                        {{- $path := (printf "/stacks/%s/services/%s/containers" $stackName $serviceName) -}}

                        {{- range $containerIdx, $containerId := ls $path }}
        vdir.add_backend( {{ printf "backend_%d_%d_%d" $stackIdx $serviceIdx $containerIdx }} );
                        {{- end -}}
                {{ end -}}
        {{- end -}}

{{- end }}
}

# Customised 'vcl_hit'.
sub vcl_hit {
	return (deliver);
}

sub vcl_recv {

    # send all traffic to the bar director:
    set req.backend_hint = vdir.backend();
    unset req.http.Cache-Control;

    {{- if eq (getenv "NOBOTS") "true" -}}
        {{- template "NOBOTS" -}}
    {{- end -}}

	{{/* If we want to cache authorization headers we need to return (hash) here as the builtin does a return (pass) if req.http.Authorization exists */}}
	{{- if eq (getenv "VARY_AUTH") "true" -}}
		if ( req.http.Authorization ) {
			return (hash);
		}
	{{- end }}
}

sub vcl_backend_response {
    # Happens after we have read the response headers from the backend.
    #
    # Here you clean the response headers, removing silly Set-Cookie headers
    # and other mistakes your backend does.

	set beresp.ttl = 45s;
	set beresp.grace = 8760h;
}

sub vcl_deliver {
    # Happens when we have all the pieces we need, and are about to send the
    # response to the client.
    #
    # You can do accounting or modifying the final object here.

    if (obj.hits > 0) {
		 set resp.http.X-Cache = "HIT";
	 } else {
		 set resp.http.X-Cache = "MISS";
	 }
}

sub vcl_hash {
	{{/* If we cache responses with the authorization header it needs to be added to the hash */}}
	{{- if eq (getenv "VARY_AUTH") "true" -}}
		hash_data(req.http.Authorization);
	{{- end }}

    hash_data(req.http.method);
}
